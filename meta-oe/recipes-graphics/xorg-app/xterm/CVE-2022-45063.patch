From 915ee1f749a6aaa77bf1a69948434312f45c17c3 Mon Sep 17 00:00:00 2001
From: Vijay Anusuri <vanusuri@mvista.com>
Date: Mon, 16 Jan 2023 04:50:05 +0000
Subject: [PATCH] CVE-2022-45063

snapshot of project "xterm", label xterm-374c

Upstream-Status: Backport [https://github.com/ThomasDickey/xterm-snapshots/commit/787636674918873a091e7a4ef5977263ba982322]
CVE: CVE-2022-45063
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 button.c       |  16 +---
 charproc.c     |   9 +-
 doublechr.c    |   4 +-
 fontutils.c    | 251 ++++++++++++++++++++++++++-----------------------
 fontutils.h    |   4 +-
 misc.c         |   7 +-
 screen.c       |   2 +-
 xterm.h        |   2 +-
 xterm.log.html |   6 ++
 9 files changed, 155 insertions(+), 146 deletions(-)

diff --git a/button.c b/button.c
index 1d20600..ca75fdb 100644
--- a/button.c
+++ b/button.c
@@ -1562,14 +1562,9 @@ static void
 UnmapSelections(XtermWidget xw)
 {
     TScreen *screen = TScreenOf(xw);
-    Cardinal n;
 
-    if (screen->mappedSelect) {
-	for (n = 0; screen->mappedSelect[n] != 0; ++n)
-	    free((void *) screen->mappedSelect[n]);
-	free(screen->mappedSelect);
-	screen->mappedSelect = 0;
-    }
+    free(screen->mappedSelect);
+    screen->mappedSelect = 0;
 }
 
 /*
@@ -1605,14 +1600,11 @@ MapSelections(XtermWidget xw, String *params, Cardinal num_params)
 	    if ((result = TypeMallocN(String, num_params + 1)) != 0) {
 		result[num_params] = 0;
 		for (j = 0; j < num_params; ++j) {
-		    result[j] = x_strdup((isSELECT(params[j])
+		    result[j] = (String) (isSELECT(params[j])
 					  ? mapTo
-					  : params[j]));
+					  : params[j]);
 		    if (result[j] == 0) {
 			UnmapSelections(xw);
-			while (j != 0) {
-			    free((void *) result[--j]);
-			}
 			free(result);
 			result = 0;
 			break;
diff --git a/charproc.c b/charproc.c
index 31cd8bc..a3f7186 100644
--- a/charproc.c
+++ b/charproc.c
@@ -11356,7 +11356,6 @@ DoSetSelectedFont(Widget w,
 	Bell(xw, XkbBI_MinorError, 0);
     } else {
 	Boolean failed = False;
-	int oldFont = TScreenOf(xw)->menu_font_number;
 	char *save = TScreenOf(xw)->SelectFontName();
 	char *val;
 	char *test = 0;
@@ -11401,10 +11400,6 @@ DoSetSelectedFont(Widget w,
 		failed = True;
 	    }
 	    if (failed) {
-		(void) xtermLoadFont(term,
-				     xtermFontName(TScreenOf(xw)->MenuFontName(oldFont)),
-				     True,
-				     oldFont);
 		Bell(xw, XkbBI_MinorError, 0);
 	    }
 	    free(used);
@@ -11413,7 +11408,7 @@ DoSetSelectedFont(Widget w,
     }
 }
 
-void
+Bool
 FindFontSelection(XtermWidget xw, const char *atom_name, Bool justprobe)
 {
     TScreen *screen = TScreenOf(xw);
@@ -11453,7 +11448,7 @@ FindFontSelection(XtermWidget xw, const char *atom_name, Bool justprobe)
 			    DoSetSelectedFont, NULL,
 			    XtLastTimestampProcessed(XtDisplay(xw)));
     }
-    return;
+    return (screen->SelectFontName() != NULL) ? True : False;
 }
 
 Bool
diff --git a/doublechr.c b/doublechr.c
index 5c6bb57..9ea9c2a 100644
--- a/doublechr.c
+++ b/doublechr.c
@@ -296,7 +296,7 @@ xterm_DoubleGC(XtermWidget xw,
 	    temp.flags = (attr_flags & BOLD);
 	    temp.warn = fwResource;
 
-	    if (!xtermOpenFont(xw, name, &temp, False)) {
+	    if (!xtermOpenFont(xw, name, &temp, NULL, False)) {
 		/* Retry with * in resolutions */
 		char *nname = xtermSpecialFont(xw,
 					       attr_flags,
@@ -305,7 +305,7 @@ xterm_DoubleGC(XtermWidget xw,
 
 		if (nname != 0) {
 		    found = (Boolean) xtermOpenFont(xw, nname, &temp,
-						    False);
+						    NULL, False);
 		    free(nname);
 		}
 	    } else {
diff --git a/fontutils.c b/fontutils.c
index 6db575e..0058072 100644
--- a/fontutils.c
+++ b/fontutils.c
@@ -90,9 +90,9 @@
 }
 
 #define FREE_FNAME(field) \
-	    if (fonts == 0 || myfonts.field != fonts->field) { \
-		FREE_STRING(myfonts.field); \
-		myfonts.field = 0; \
+            if (fonts == 0 || new_fnames.field != fonts->field) { \
+                FREE_STRING(new_fnames.field); \
+                new_fnames.field = 0; \
 	    }
 
 /*
@@ -483,7 +483,7 @@ open_italic_font(XtermWidget xw, int n, FontNameProperties *fp, XTermFonts * dat
 	if ((name = italic_font_name(fp, slant[pass])) != 0) {
 	    TRACE(("open_italic_font %s %s\n",
 		   whichFontEnum((VTFontEnum) n), name));
-	    if (xtermOpenFont(xw, name, data, False)) {
+	    if (xtermOpenFont(xw, name, data, NULL, False)) {
 		result = (data->fs != 0);
 #if OPT_REPORT_FONTS
 		if (resource.reportFonts) {
@@ -907,19 +907,24 @@ cannotFont(XtermWidget xw, const char *who, const char *what, const char *where)
 }
 
 /*
- * Open the given font and verify that it is non-empty.  Return a null on
+ * Open the given font and verify that it is non-empty.  Return false on
  * failure.
  */
 Bool
 xtermOpenFont(XtermWidget xw,
 	      const char *name,
 	      XTermFonts * result,
+              XTermFonts * current,
 	      Bool force)
 {
     Bool code = False;
     TScreen *screen = TScreenOf(xw);
 
     if (!IsEmpty(name)) {
+        Bool existing = (current != NULL
+                         && current->fs != NULL
+                         && current->fn != NULL);
+
 	if ((result->fs = XLoadQueryFont(screen->display, name)) != 0) {
 	    code = True;
 	    if (EmptyFont(result->fs)) {
@@ -939,9 +944,13 @@ xtermOpenFont(XtermWidget xw,
 	    } else {
 		TRACE(("xtermOpenFont: cannot load font '%s'\n", name));
 	    }
-	    if (force) {
+            if (existing) {
+                TRACE(("...continue using font '%s'\n", current->fn));
+                result->fn = x_strdup(current->fn);
+                result->fs = current->fs;
+            } else if (force) {
 		result->warn = fwAlways;
-		code = xtermOpenFont(xw, DEFFONT, result, True);
+		code = xtermOpenFont(xw, DEFFONT, result, NULL, True);
 	    }
 	}
     }
@@ -1184,6 +1193,7 @@ static Bool
 loadNormFP(XtermWidget xw,
 	   char **nameOutP,
 	   XTermFonts * infoOut,
+           XTermFonts * current,
 	   int fontnum)
 {
     Bool status = True;
@@ -1193,7 +1203,7 @@ loadNormFP(XtermWidget xw,
     if (!xtermOpenFont(xw,
 		       *nameOutP,
 		       infoOut,
-		       (fontnum == fontMenu_default))) {
+		       current, (fontnum == fontMenu_default))) {
 	/*
 	 * If we are opening the default font, and it happens to be missing,
 	 * force that to the compiled-in default font, e.g., "fixed".  If we
@@ -1227,10 +1237,10 @@ loadBoldFP(XtermWidget xw,
 	fp = get_font_name_props(screen->display, infoRef->fs, &normal);
 	if (fp != 0) {
 	    *nameOutP = bold_font_name(fp, fp->average_width);
-	    if (!xtermOpenFont(xw, *nameOutP, infoOut, False)) {
+	    if (!xtermOpenFont(xw, *nameOutP, infoOut, NULL, False)) {
 		free(*nameOutP);
 		*nameOutP = bold_font_name(fp, -1);
-		xtermOpenFont(xw, *nameOutP, infoOut, False);
+		xtermOpenFont(xw, *nameOutP, infoOut, NULL, False);
 	    }
 	    TRACE(("...derived bold '%s'\n", NonNull(*nameOutP)));
 	}
@@ -1248,7 +1258,7 @@ loadBoldFP(XtermWidget xw,
 	    TRACE(("...did not get a matching bold font\n"));
 	}
 	free(normal);
-    } else if (!xtermOpenFont(xw, *nameOutP, infoOut, False)) {
+    } else if (!xtermOpenFont(xw, *nameOutP, infoOut, NULL, False)) {
 	xtermCopyFontInfo(infoOut, infoRef);
 	TRACE(("...cannot load bold font '%s'\n", NonNull(*nameOutP)));
     } else {
@@ -1304,7 +1314,7 @@ loadWideFP(XtermWidget xw,
     }
 
     if (check_fontname(*nameOutP)) {
-	if (!xtermOpenFont(xw, *nameOutP, infoOut, False)) {
+	if (!xtermOpenFont(xw, *nameOutP, infoOut, NULL, False)) {
 	    xtermCopyFontInfo(infoOut, infoRef);
 	}
     } else {
@@ -1340,7 +1350,7 @@ loadWBoldFP(XtermWidget xw,
 
     if (check_fontname(*nameOutP)) {
 
-	if (xtermOpenFont(xw, *nameOutP, infoOut, False)
+	if (xtermOpenFont(xw, *nameOutP, infoOut, NULL, False)
 	    && derived
 	    && !compatibleWideCounts(wideInfoRef->fs, infoOut->fs)) {
 	    xtermCloseFont2(xw, infoOut - fWBold, fWBold);
@@ -1393,6 +1403,10 @@ loadWBoldFP(XtermWidget xw,
 }
 #endif
 
+/*
+ * Load a given bitmap font, along with the bold/wide variants.
+ * Returns nonzero on success.
+ */
 int
 xtermLoadFont(XtermWidget xw,
 	      const VTFontNames * fonts,
@@ -1402,33 +1416,37 @@ xtermLoadFont(XtermWidget xw,
     TScreen *screen = TScreenOf(xw);
     VTwin *win = WhichVWin(screen);
 
-    VTFontNames myfonts;
-    XTermFonts fnts[fMAX];
+    VTFontNames new_fnames;
+    XTermFonts new_fonts[fMAX];
+    XTermFonts old_fonts[fMAX];
     char *tmpname = NULL;
     Boolean proportional = False;
+    Boolean recovered;
+    int code = 0;
 
-    memset(&myfonts, 0, sizeof(myfonts));
-    memset(fnts, 0, sizeof(fnts));
+    memset(&new_fnames, 0, sizeof(new_fnames));
+    memset(new_fonts, 0, sizeof(new_fonts));
+    memcpy(&old_fonts, screen->fnts, sizeof(old_fonts));
 
     if (fonts != 0)
-	myfonts = *fonts;
-    if (!check_fontname(myfonts.f_n))
-	return 0;
+        new_fnames = *fonts;
+    if (!check_fontname(new_fnames.f_n))
+        return code;
 
     if (fontnum == fontMenu_fontescape
-	&& myfonts.f_n != screen->MenuFontName(fontnum)) {
-	if ((tmpname = x_strdup(myfonts.f_n)) == 0)
-	    return 0;
+        && new_fnames.f_n != screen->MenuFontName(fontnum)) {
+        if ((tmpname = x_strdup(new_fnames.f_n)) == 0)
+            return code;
     }
 
-    TRACE(("Begin Cgs - xtermLoadFont(%s)\n", myfonts.f_n));
+    TRACE(("Begin Cgs - xtermLoadFont(%s)\n", new_fnames.f_n));
     releaseWindowGCs(xw, win);
 
 #define DbgResource(name, field, index) \
     TRACE(("xtermLoadFont #%d "name" %s%s\n", \
     	   fontnum, \
-	   (fnts[index].warn == fwResource) ? "*" : " ", \
-	   NonNull(myfonts.field)))
+           (new_fonts[index].warn == fwResource) ? "*" : " ", \
+           NonNull(new_fnames.field)))
     DbgResource("normal", f_n, fNorm);
     DbgResource("bold  ", f_b, fBold);
 #if OPT_WIDE_CHARS
@@ -1437,16 +1455,17 @@ xtermLoadFont(XtermWidget xw,
 #endif
 
     if (!loadNormFP(xw,
-		    &myfonts.f_n,
-		    &fnts[fNorm],
+                    &new_fnames.f_n,
+                    &new_fonts[fNorm],
+                    &old_fonts[fNorm],
 		    fontnum))
 	goto bad;
 
     if (!loadBoldFP(xw,
-		    &myfonts.f_b,
-		    &fnts[fBold],
-		    myfonts.f_n,
-		    &fnts[fNorm],
+                    &new_fnames.f_b,
+                    &new_fonts[fBold],
+                    new_fnames.f_n,
+                    &new_fonts[fNorm],
 		    fontnum))
 	goto bad;
 
@@ -1458,20 +1477,20 @@ xtermLoadFont(XtermWidget xw,
     if_OPT_WIDE_CHARS(screen, {
 
 	if (!loadWideFP(xw,
-			&myfonts.f_w,
-			&fnts[fWide],
-			myfonts.f_n,
-			&fnts[fNorm],
+                        &new_fnames.f_w,
+                        &new_fonts[fWide],
+                        new_fnames.f_n,
+                        &new_fonts[fNorm],
 			fontnum))
 	    goto bad;
 
 	if (!loadWBoldFP(xw,
-			 &myfonts.f_wb,
-			 &fnts[fWBold],
-			 myfonts.f_w,
-			 &fnts[fWide],
-			 myfonts.f_b,
-			 &fnts[fBold],
+                         &new_fnames.f_wb,
+                         &new_fonts[fWBold],
+                         new_fnames.f_w,
+                         &new_fonts[fWide],
+                         new_fnames.f_b,
+                         &new_fonts[fBold],
 			 fontnum))
 	    goto bad;
 
@@ -1481,28 +1500,28 @@ xtermLoadFont(XtermWidget xw,
      * Normal/bold fonts should be the same width.  Also, the min/max
      * values should be the same.
      */
-    if (!is_fixed_font(fnts[fNorm].fs)
-	|| !is_fixed_font(fnts[fBold].fs)
-	|| fnts[fNorm].fs->max_bounds.width != fnts[fBold].fs->max_bounds.width) {
+    if (!is_fixed_font(new_fonts[fNorm].fs)
+	|| !is_fixed_font(new_fonts[fBold].fs)
+	|| new_fonts[fNorm].fs->max_bounds.width != new_fonts[fBold].fs->max_bounds.width) {
 	TRACE(("Proportional font! normal %d/%d, bold %d/%d\n",
-	       fnts[fNorm].fs->min_bounds.width,
-	       fnts[fNorm].fs->max_bounds.width,
-	       fnts[fBold].fs->min_bounds.width,
-	       fnts[fBold].fs->max_bounds.width));
+	       new_fonts[fNorm].fs->min_bounds.width,
+	       new_fonts[fNorm].fs->max_bounds.width,
+	       new_fonts[fBold].fs->min_bounds.width,
+	       new_fonts[fBold].fs->max_bounds.width));
 	proportional = True;
     }
 
     if_OPT_WIDE_CHARS(screen, {
-	if (fnts[fWide].fs != 0
-	    && fnts[fWBold].fs != 0
-	    && (!is_fixed_font(fnts[fWide].fs)
-		|| !is_fixed_font(fnts[fWBold].fs)
-		|| fnts[fWide].fs->max_bounds.width != fnts[fWBold].fs->max_bounds.width)) {
+	if (new_fonts[fWide].fs != 0
+	    && new_fonts[fWBold].fs != 0
+	    && (!is_fixed_font(new_fonts[fWide].fs)
+		|| !is_fixed_font(new_fonts[fWBold].fs)
+		|| new_fonts[fWide].fs->max_bounds.width != new_fonts[fWBold].fs->max_bounds.width)) {
 	    TRACE(("Proportional font! wide %d/%d, wide bold %d/%d\n",
-		   fnts[fWide].fs->min_bounds.width,
-		   fnts[fWide].fs->max_bounds.width,
-		   fnts[fWBold].fs->min_bounds.width,
-		   fnts[fWBold].fs->max_bounds.width));
+		   new_fonts[fWide].fs->min_bounds.width,
+		   new_fonts[fWide].fs->max_bounds.width,
+		   new_fonts[fWBold].fs->min_bounds.width,
+		   new_fonts[fWBold].fs->max_bounds.width));
 	    proportional = True;
 	}
     });
@@ -1521,13 +1540,13 @@ xtermLoadFont(XtermWidget xw,
     screen->ifnts_ok = False;
 #endif
 
-    xtermCopyFontInfo(getNormalFont(screen, fNorm), &fnts[fNorm]);
-    xtermCopyFontInfo(getNormalFont(screen, fBold), &fnts[fBold]);
+    xtermCopyFontInfo(getNormalFont(screen, fNorm), &new_fonts[fNorm]);
+    xtermCopyFontInfo(getNormalFont(screen, fBold), &new_fonts[fBold]);
 #if OPT_WIDE_CHARS
-    xtermCopyFontInfo(getNormalFont(screen, fWide), &fnts[fWide]);
-    if (fnts[fWBold].fs == NULL)
-	xtermCopyFontInfo(getNormalFont(screen, fWide), &fnts[fWide]);
-    xtermCopyFontInfo(getNormalFont(screen, fWBold), &fnts[fWBold]);
+    xtermCopyFontInfo(getNormalFont(screen, fWide), &new_fonts[fWide]);
+    if (new_fonts[fWBold].fs == NULL)
+	xtermCopyFontInfo(getNormalFont(screen, fWide), &new_fonts[fWide]);
+    xtermCopyFontInfo(getNormalFont(screen, fWBold), &new_fonts[fWBold]);
 #endif
 
     xtermUpdateFontGCs(xw, False);
@@ -1558,7 +1577,7 @@ xtermLoadFont(XtermWidget xw,
 	unsigned ch;
 
 #if OPT_TRACE
-#define TRACE_MISS(index) show_font_misses(#index, &fnts[index])
+#define TRACE_MISS(index) show_font_misses(#index, &new_fonts[index])
 	TRACE_MISS(fNorm);
 	TRACE_MISS(fBold);
 #if OPT_WIDE_CHARS
@@ -1576,12 +1595,12 @@ xtermLoadFont(XtermWidget xw,
 		    continue;
 	    }
 #endif
-	    if (IsXtermMissingChar(screen, n, &fnts[fNorm])) {
+	    if (IsXtermMissingChar(screen, n, &new_fonts[fNorm])) {
 		TRACE(("missing normal char #%d\n", n));
 		screen->fnt_boxes = False;
 		break;
 	    }
-	    if (IsXtermMissingChar(screen, n, &fnts[fBold])) {
+	    if (IsXtermMissingChar(screen, n, &new_fonts[fBold])) {
 		TRACE(("missing bold char #%d\n", n));
 		screen->fnt_boxes = False;
 		break;
@@ -1596,8 +1615,8 @@ xtermLoadFont(XtermWidget xw,
 	screen->enbolden = screen->bold_mode;
     } else {
 	screen->enbolden = screen->bold_mode
-	    && ((fnts[fNorm].fs == fnts[fBold].fs)
-		|| same_font_name(myfonts.f_n, myfonts.f_b));
+	    && ((new_fonts[fNorm].fs == new_fonts[fBold].fs)
+		|| same_font_name(new_fnames.f_n, new_fnames.f_b));
     }
     TRACE(("Will %suse 1-pixel offset/overstrike to simulate bold\n",
 	   screen->enbolden ? "" : "not "));
@@ -1613,7 +1632,7 @@ xtermLoadFont(XtermWidget xw,
 	    update_font_escape();
 	}
 #if OPT_SHIFT_FONTS
-	screen->menu_font_sizes[fontnum] = FontSize(fnts[fNorm].fs);
+	screen->menu_font_sizes[fontnum] = FontSize(new_fonts[fNorm].fs);
 #endif
     }
     set_cursor_gcs(xw);
@@ -1628,20 +1647,21 @@ xtermLoadFont(XtermWidget xw,
     FREE_FNAME(f_w);
     FREE_FNAME(f_wb);
 #endif
-    if (fnts[fNorm].fn == fnts[fBold].fn) {
-	free(fnts[fNorm].fn);
+    if (new_fonts[fNorm].fn == new_fonts[fBold].fn) {
+	free(new_fonts[fNorm].fn);
     } else {
-	free(fnts[fNorm].fn);
-	free(fnts[fBold].fn);
+	free(new_fonts[fNorm].fn);
+	free(new_fonts[fBold].fn);
     }
 #if OPT_WIDE_CHARS
-    free(fnts[fWide].fn);
-    free(fnts[fWBold].fn);
+    free(new_fonts[fWide].fn);
+    free(new_fonts[fWBold].fn);
 #endif
     xtermSetWinSize(xw);
     return 1;
 
   bad:
+    recovered = False;
     if (tmpname)
 	free(tmpname);
 
@@ -1652,15 +1672,15 @@ xtermLoadFont(XtermWidget xw,
 	SetItemSensitivity(fontMenuEntries[fontnum].widget, True);
 #endif
 	Bell(xw, XkbBI_MinorError, 0);
-	myfonts.f_n = screen->MenuFontName(old_fontnum);
-	return xtermLoadFont(xw, &myfonts, doresize, old_fontnum);
-    } else if (x_strcasecmp(myfonts.f_n, DEFFONT)) {
-	int code;
-
-	myfonts.f_n = x_strdup(DEFFONT);
-	TRACE(("...recovering for TrueType fonts\n"));
-	code = xtermLoadFont(xw, &myfonts, doresize, fontnum);
-	if (code) {
+	new_fnames.f_n = screen->MenuFontName(old_fontnum);
+	if xtermLoadFont(xw, &new_fnames, doresize, old_fontnum);
+           recovered = True;
+    } else if (x_strcasecmp(new_fnames.f_n, DEFFONT)
+         && x_strcasecmp(new_fnames.f_n, old_fonts[fNorm].fn)) {
+        new_fnames.f_n = x_strdup(old_fonts[fNorm].fn);
+        TRACE(("...recovering from failed font-load\n"));
+        if (xtermLoadFont(xw, &new_fnames, doresize, fontnum)) {
+            recovered = True;
 	    if (fontnum != fontMenu_fontsel) {
 		SetItemSensitivity(fontMenuEntries[fontnum].widget,
 				   UsingRenderFont(xw));
@@ -1669,15 +1689,15 @@ xtermLoadFont(XtermWidget xw,
 		   FontHeight(screen),
 		   FontWidth(screen)));
 	}
-	return code;
     }
 #endif
-
+    if (!recovered) {
     releaseWindowGCs(xw, win);
-
-    xtermCloseFonts(xw, fnts);
+    xtermCloseFonts(xw, new_fonts);
     TRACE(("Fail Cgs - xtermLoadFont\n"));
-    return 0;
+    code = 0;
+    }
+    return code;
 }
 
 #if OPT_WIDE_ATTRS
@@ -1725,7 +1745,7 @@ xtermLoadItalics(XtermWidget xw)
 			} else {
 			    xtermOpenFont(xw,
 					  getNormalFont(screen, n)->fn,
-					  data, False);
+					  data, NULL, False);
 			}
 		    }
 		}
@@ -3357,7 +3377,7 @@ lookupOneFontSize(XtermWidget xw, int fontnum)
 
 	memset(&fnt, 0, sizeof(fnt));
 	screen->menu_font_sizes[fontnum] = -1;
-	if (xtermOpenFont(xw, screen->MenuFontName(fontnum), &fnt, True)) {
+	if (xtermOpenFont(xw, screen->MenuFontName(fontnum), &fnt, NULL, True)) {
 	    if (fontnum <= fontMenu_lastBuiltin
 		|| strcmp(fnt.fn, DEFFONT)) {
 		screen->menu_font_sizes[fontnum] = FontSize(fnt.fs);
@@ -3762,13 +3782,14 @@ HandleSetFont(Widget w GCC_UNUSED,
     }
 }
 
-void
+Bool
 SetVTFont(XtermWidget xw,
 	  int which,
 	  Bool doresize,
 	  const VTFontNames * fonts)
 {
     TScreen *screen = TScreenOf(xw);
+    Bool result = False;
 
     TRACE(("SetVTFont(which=%d, f_n=%s, f_b=%s)\n", which,
 	   (fonts && fonts->f_n) ? fonts->f_n : "<null>",
@@ -3777,34 +3798,31 @@ SetVTFont(XtermWidget xw,
     if (IsIcon(screen)) {
 	Bell(xw, XkbBI_MinorError, 0);
     } else if (which >= 0 && which < NMENUFONTS) {
-	VTFontNames myfonts;
+	VTFontNames new_fnames;
 
-	memset(&myfonts, 0, sizeof(myfonts));
+	memset(&new_fnames, 0, sizeof(new_fnames));
 	if (fonts != 0)
-	    myfonts = *fonts;
+	    new_fnames = *fonts;
 
 	if (which == fontMenu_fontsel) {	/* go get the selection */
-	    FindFontSelection(xw, myfonts.f_n, False);
+	    result = FindFontSelection(xw, new_fnames.f_n, False);
 	} else {
-	    int oldFont = screen->menu_font_number;
-
 #define USE_CACHED(field, name) \
-	    if (myfonts.field == 0) { \
-		myfonts.field = x_strdup(screen->menu_font_names[which][name]); \
-		TRACE(("set myfonts." #field " from menu_font_names[%d][" #name "] %s\n", \
-		       which, NonNull(myfonts.field))); \
+        if (new_fnames.field == NULL) { \
+            new_fnames.field = x_strdup(screen->menu_font_names[which][name]); \
+            TRACE(("set new_fnames." #field " from menu_font_names[%d][" #name "] %s\n", \
+                which, NonNull(new_fnames.field))); \
 	    } else { \
-		TRACE(("set myfonts." #field " reused\n")); \
+		TRACE(("set new_fnames." #field " reused\n")); \
 	    }
 #define SAVE_FNAME(field, name) \
-	    if (myfonts.field != 0) { \
-		if (screen->menu_font_names[which][name] == 0 \
-		 || strcmp(screen->menu_font_names[which][name], myfonts.field)) { \
-		    TRACE(("updating menu_font_names[%d][" #name "] to %s\n", \
-			   which, myfonts.field)); \
-		    FREE_STRING(screen->menu_font_names[which][name]); \
-		    screen->menu_font_names[which][name] = x_strdup(myfonts.field); \
-		} \
+            if (new_fnames.field != NULL \
+                && (screen->menu_font_names[which][name] == NULL \
+                || strcmp(screen->menu_font_names[which][name], new_fnames.field))) { \
+                TRACE(("updating menu_font_names[%d][" #name "] to \"%s\"\n", \
+                   which, new_fnames.field)); \
+                FREE_STRING(screen->menu_font_names[which][name]); \
+                screen->menu_font_names[which][name] = x_strdup(new_fnames.field); \
 	    }
 
 	    USE_CACHED(f_n, fNorm);
@@ -3814,7 +3832,7 @@ SetVTFont(XtermWidget xw,
 	    USE_CACHED(f_wb, fWBold);
 #endif
 	    if (xtermLoadFont(xw,
-			      &myfonts,
+			      &new_fnames,
 			      doresize, which)) {
 		/*
 		 * If successful, save the data so that a subsequent query via
@@ -3826,10 +3844,8 @@ SetVTFont(XtermWidget xw,
 		SAVE_FNAME(f_w, fWide);
 		SAVE_FNAME(f_wb, fWBold);
 #endif
+                result = True;
 	    } else {
-		(void) xtermLoadFont(xw,
-				     xtermFontName(screen->MenuFontName(oldFont)),
-				     doresize, oldFont);
 		Bell(xw, XkbBI_MinorError, 0);
 	    }
 	    FREE_FNAME(f_n);
@@ -3842,7 +3858,8 @@ SetVTFont(XtermWidget xw,
     } else {
 	Bell(xw, XkbBI_MinorError, 0);
     }
-    return;
+    TRACE(("...SetVTFont: %d\n", result));
+    return result;
 }
 
 #if OPT_RENDERFONT
diff --git a/fontutils.h b/fontutils.h
index 188cca5..bf157e3 100644
--- a/fontutils.h
+++ b/fontutils.h
@@ -37,7 +37,7 @@
 /* *INDENT-OFF* */
 
 extern Bool xtermLoadDefaultFonts (XtermWidget /* xw */);
-extern Bool xtermOpenFont (XtermWidget /* xw */, const char */* name */, XTermFonts * /* result */, Bool /* force */);
+extern Bool xtermOpenFont (XtermWidget /* xw */, const char */* name */, XTermFonts * /* result */, XTermFonts * /* current */, Bool /* force */);
 extern XTermFonts * getDoubleFont (TScreen * /* screen */, int /* which */);
 extern XTermFonts * getItalicFont (TScreen * /* screen */, int /* which */);
 extern XTermFonts * getNormalFont (TScreen * /* screen */, int /* which */);
@@ -50,7 +50,7 @@ extern int lookupRelativeFontSize (XtermWidget /* xw */, int /* old */, int /* r
 extern int xtermGetFont (const char * /* param */);
 extern int xtermLoadFont (XtermWidget /* xw */, const VTFontNames */* fonts */, Bool /* doresize */, int /* fontnum */);
 extern void HandleSetFont PROTO_XT_ACTIONS_ARGS;
-extern void SetVTFont (XtermWidget /* xw */, int /* i */, Bool /* doresize */, const VTFontNames */* fonts */);
+extern Bool SetVTFont (XtermWidget /* xw */, int /* i */, Bool /* doresize */, const VTFontNames */* fonts */);
 extern void allocFontList (XtermWidget /* xw */, const char * /* name */, XtermFontNames * /* target */, VTFontEnum /* which */, const char * /* source */, Bool /* ttf */);
 extern void copyFontList (char *** /* targetp */, char ** /* source */);
 extern void initFontLists (XtermWidget /* xw */);
diff --git a/misc.c b/misc.c
index 8d2aa6f..b3197ff 100644
--- a/misc.c
+++ b/misc.c
@@ -3484,9 +3484,9 @@ ChangeFontRequest(XtermWidget xw, String buf)
 	    {
 		memset(&fonts, 0, sizeof(fonts));
 		fonts.f_n = name;
-		SetVTFont(xw, num, True, &fonts);
-		if (num == screen->menu_font_number &&
-		    num != fontMenu_fontescape) {
+                if (SetVTFont(xw, num, True, &fonts)
+                    && num == screen->menu_font_number
+                    && num != fontMenu_fontescape) {
 		    screen->EscapeFontName() = x_strdup(name);
 		}
 	    }
@@ -5494,7 +5494,6 @@ xtermSetenv(const char *var, const char *value)
 
 	    found = envindex;
 	    environ[found + 1] = NULL;
-	    environ = environ;
 	}
 
 	environ[found] = TextAlloc(1 + len + strlen(value));
diff --git a/screen.c b/screen.c
index 7643a57..bad92f9 100644
--- a/screen.c
+++ b/screen.c
@@ -1433,7 +1433,7 @@ ScrnRefresh(XtermWidget xw,
 	   screen->topline, toprow, leftcol,
 	   nrows, ncols,
 	   force ? " force" : ""));
-
+    (void) recurse;
     ++recurse;
 
     if (screen->cursorp.col >= leftcol
diff --git a/xterm.h b/xterm.h
index 074c6f9..05612be 100644
--- a/xterm.h
+++ b/xterm.h
@@ -894,7 +894,7 @@ extern void noleaks_cachedCgs (XtermWidget /* xw */);
 extern Bool CheckBufPtrs (TScreen * /* screen */);
 extern Bool set_cursor_gcs (XtermWidget /* xw */);
 extern int VTInit (XtermWidget /* xw */);
-extern void FindFontSelection (XtermWidget /* xw */, const char * /* atom_name */, Bool  /* justprobe */);
+extern Bool FindFontSelection (XtermWidget /* xw */, const char * /* atom_name */, Bool  /* justprobe */);
 extern void HideCursor (void);
 extern void RestartBlinking(TScreen * /* screen */);
 extern void ShowCursor (void);
diff --git a/xterm.log.html b/xterm.log.html
index 2280dca..bd03683 100644
--- a/xterm.log.html
+++ b/xterm.log.html
@@ -952,6 +952,12 @@
     <li>updates for ReGIS (Ross Combs):
 
       <ul>
+        <li>improve error-recovery when setting a bitmap font for the
+        VT100 window, e.g., in case <em>OSC&nbsp;50</em> failed,
+        restoring the most recent valid font so that a subsequent
+        <em>OSC&nbsp;50</em> reports this correctly (report by David
+        Leadbeater).</li>
+
         <li>remove redundant text command error check which broke
         <code>T(B)</code> and <code>T(E)</code>.</li>
 
-- 
2.18.2

