From 8480a3f99a35c122c9e7afcab518ff0c8369e755 Mon Sep 17 00:00:00 2001
From: Hitendra Prajapati <hprajapati@mvista.com>
Date: Mon, 7 Feb 2022 10:07:10 +0530
Subject: [PATCH] CVE-2021-4069

Upstream-Status: Backport from https://github.com/vim/vim/commit/e031fe90cf2e375ce861ff5e5e281e4ad229ebb9

Signed-off-by: Hitendra Prajapati <hprajapati@mvista.com>
---
 src/ex_docmd.c               | 10 ++++--
 src/testdir/Make_all.mak     |  1 +
 src/testdir/test_alot.vim    |  1 +
 src/testdir/test_cmdline.vim | 39 +++++++++++++++------
 src/testdir/test_ex_mode.vim | 67 ++++++++++++++++++++++++++++++++++++
 src/version.c                |  2 ++
 6 files changed, 107 insertions(+), 13 deletions(-)
 create mode 100644 src/testdir/test_ex_mode.vim

diff --git a/src/ex_docmd.c b/src/ex_docmd.c
index 2a9971003..7c4f7c851 100644
--- a/src/ex_docmd.c
+++ b/src/ex_docmd.c
@@ -8633,13 +8633,17 @@ ex_open(exarg_T *eap)
 	regmatch.regprog = vim_regcomp(eap->arg, p_magic ? RE_MAGIC : 0);
 	if (regmatch.regprog != NULL)
 	{
+	    // make a copy of the line, when searching for a mark it might be
+	    // flushed
+	    char_u *line = vim_strsave(ml_get_curline());
+
 	    regmatch.rm_ic = p_ic;
-	    p = ml_get_curline();
-	    if (vim_regexec(&regmatch, p, (colnr_T)0))
-		curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - p);
+	    if (vim_regexec(&regmatch, line, (colnr_T)0))
+		curwin->w_cursor.col = (colnr_T)(regmatch.startp[0] - line);
 	    else
 		EMSG(_(e_nomatch));
 	    vim_regfree(regmatch.regprog);
+	    vim_free(line);
 	}
 	/* Move to the NUL, ignore any other arguments. */
 	eap->arg += STRLEN(eap->arg);
diff --git a/src/testdir/Make_all.mak b/src/testdir/Make_all.mak
index b12ede543..bd980f585 100644
--- a/src/testdir/Make_all.mak
+++ b/src/testdir/Make_all.mak
@@ -132,6 +132,7 @@ NEW_TESTS = test_arabic.res \
 	    test_digraph.res \
 	    test_display.res \
 	    test_edit.res \
+	    test_ex_mode \
 	    test_farsi.res \
 	    test_file_size.res \
 	    test_fnameescape.res \
diff --git a/src/testdir/test_alot.vim b/src/testdir/test_alot.vim
index e83256a4d..1b651c126 100644
--- a/src/testdir/test_alot.vim
+++ b/src/testdir/test_alot.vim
@@ -9,6 +9,7 @@ source test_cursor_func.vim
 source test_delete.vim
 source test_ex_undo.vim
 source test_ex_z.vim
+source test_ex_mode.vim
 source test_execute_func.vim
 source test_expand.vim
 source test_expand_dllpath.vim
diff --git a/src/testdir/test_cmdline.vim b/src/testdir/test_cmdline.vim
index f9499acf0..1694b3edd 100644
--- a/src/testdir/test_cmdline.vim
+++ b/src/testdir/test_cmdline.vim
@@ -288,7 +288,7 @@ func Test_expand_star_star()
   call delete('a', 'rf')
 endfunc
 
-func Test_paste_in_cmdline()
+func Test_cmdline_paste()
   let @a = "def"
   call feedkeys(":abc \<C-R>a ghi\<C-B>\"\<CR>", 'tx')
   call assert_equal('"abc def ghi', @:)
@@ -314,18 +314,37 @@ func Test_paste_in_cmdline()
   bwipe!
 endfunc
 
-func Test_remove_char_in_cmdline()
-  call feedkeys(":abc def\<S-Left>\<Del>\<C-B>\"\<CR>", 'tx')
-  call assert_equal('"abc ef', @:)
+func Test_cmdline_remove_char()
+  let encoding_save = &encoding
 
-  call feedkeys(":abc def\<S-Left>\<BS>\<C-B>\"\<CR>", 'tx')
-  call assert_equal('"abcdef', @:)
+  for e in ['utf8', 'latin1']
+    exe 'set encoding=' . e
 
-  call feedkeys(":abc def ghi\<S-Left>\<C-W>\<C-B>\"\<CR>", 'tx')
-  call assert_equal('"abc ghi', @:)
+    call feedkeys(":abc def\<S-Left>\<Del>\<C-B>\"\<CR>", 'tx')
+    call assert_equal('"abc ef', @:, e)
 
-  call feedkeys(":abc def\<S-Left>\<C-U>\<C-B>\"\<CR>", 'tx')
-  call assert_equal('"def', @:)
+    call feedkeys(":abc def\<S-Left>\<BS>\<C-B>\"\<CR>", 'tx')
+    call assert_equal('"abcdef', @:)
+
+    call feedkeys(":abc def ghi\<S-Left>\<C-W>\<C-B>\"\<CR>", 'tx')
+    call assert_equal('"abc ghi', @:, e)
+
+    call feedkeys(":abc def\<S-Left>\<C-U>\<C-B>\"\<CR>", 'tx')
+    call assert_equal('"def', @:, e)
+  endfor
+
+  let &encoding = encoding_save
+endfunc
+
+func Test_cmdline_keymap_ctrl_hat()
+  if !has('keymap')
+    return
+  endif
+
+  set keymap=esperanto
+  call feedkeys(":\"Jxauxdo \<C-^>Jxauxdo \<C-^>Jxauxdo\<CR>", 'tx')
+  call assert_equal('"Jxauxdo Ĵaŭdo Jxauxdo', @:)
+  set keymap=
 endfunc
 
 func Test_illegal_address1()
diff --git a/src/testdir/test_ex_mode.vim b/src/testdir/test_ex_mode.vim
new file mode 100644
index 000000000..821a045f0
--- /dev/null
+++ b/src/testdir/test_ex_mode.vim
@@ -0,0 +1,67 @@
+" Test editing line in Ex mode (see :help Q and :help gQ).
+
+" Helper function to test editing line in Q Ex mode
+func Ex_Q(cmd)
+  " Is there a simpler way to test editing Ex line?
+  call feedkeys("Q"
+        \    .. "let s:test_ex =<< END\<CR>"
+        \    .. a:cmd .. "\<CR>"
+        \    .. "END\<CR>"
+        \    .. "visual\<CR>", 'tx')
+  return s:test_ex[0]
+endfunc
+
+" Helper function to test editing line in gQ Ex mode
+func Ex_gQ(cmd)
+  call feedkeys("gQ" .. a:cmd .. "\<C-b>\"\<CR>", 'tx')
+  let ret = @:[1:] " Remove leading quote.
+  call feedkeys("visual\<CR>", 'tx')
+  return ret
+endfunc
+
+" Helper function to test editing line with both Q and gQ Ex mode.
+func Ex(cmd)
+ return [Ex_Q(a:cmd), Ex_gQ(a:cmd)]
+endfunc
+
+" Test editing line in Ex mode (both Q and gQ)
+func Test_ex_mode()
+  let encoding_save = &encoding
+  set sw=2
+
+  for e in ['utf8', 'latin1']
+    exe 'set encoding=' . e
+
+    call assert_equal(['bar', 'bar'],             Ex("foo bar\<C-u>bar"), e)
+    call assert_equal(["1\<C-u>2", "1\<C-u>2"],   Ex("1\<C-v>\<C-u>2"), e)
+    call assert_equal(["1\<C-b>2\<C-e>3", '213'], Ex("1\<C-b>2\<C-e>3"), e)
+    call assert_equal(['0123', '2013'],           Ex("01\<Home>2\<End>3"), e)
+    call assert_equal(['0123', '0213'],           Ex("01\<Left>2\<Right>3"), e)
+    call assert_equal(['01234', '0342'],          Ex("012\<Left>\<Left>\<Insert>3\<Insert>4"), e)
+    call assert_equal(["foo bar\<C-w>", 'foo '],  Ex("foo bar\<C-w>"), e)
+    call assert_equal(['foo', 'foo'],             Ex("fooba\<Del>\<Del>"), e)
+    call assert_equal(["foo\tbar", 'foobar'],     Ex("foo\<Tab>bar"), e)
+    call assert_equal(["abbrev\t", 'abbreviate'], Ex("abbrev\<Tab>"), e)
+    call assert_equal(['    1', "1\<C-t>\<C-t>"], Ex("1\<C-t>\<C-t>"), e)
+    call assert_equal(['  1', "1\<C-t>\<C-t>"],   Ex("1\<C-t>\<C-t>\<C-d>"), e)
+    call assert_equal(['  foo', '    foo'],       Ex("    foo\<C-d>"), e)
+    call assert_equal(['foo', '    foo0'],        Ex("    foo0\<C-d>"), e)
+    call assert_equal(['foo', '    foo^'],        Ex("    foo^\<C-d>"), e)
+  endfor
+
+  set sw&
+  let &encoding = encoding_save
+endfunc
+
+func Test_open_command_flush_line()
+  " this was accessing freed memory: the regexp match uses a pointer to the
+  " current line which becomes invalid when searching for the ') mark.
+  new
+  call setline(1, ['one', 'two. three'])
+  s/one/ONE
+  try
+    open /\%')/
+  catch /E479/
+  endtry
+  bwipe!
+endfunc
diff --git a/src/version.c b/src/version.c
index fcdebf412..715aef14e 100644
--- a/src/version.c
+++ b/src/version.c
@@ -769,6 +769,8 @@ static char *(features[]) =
 
 static int included_patches[] =
 {   /* Add new patch number below this line */
+/**/
+    992,
 /**/
     991,
 /**/
-- 
2.25.1

