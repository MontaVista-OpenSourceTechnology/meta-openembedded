From 74a49d3b63acf62a713f1b9e9e6672712607c77b Mon Sep 17 00:00:00 2001
From: Andre lorbach <alorbach@adiscon.com>
Date: Thu, 2 Sep 2021 23:33:18 +0200
Subject: [PATCH] queue: Add NULL check in qDeqLinkedList

Add NULL value handling for pDeqRoot. This caused seqfaults if
messages were discarded during dequeue.

Also fix iOverallQueueSize calculation (discarded items) in imdiag.

While building a testcase for issue #4437 , I discovered an issue with the
iOverallQueueSize counter not being substracting discarded messages. This caused
the testcase to fail with testcase timeout at the count of "discardMark" queue
setting.

closes: https://github.com/rsyslog/rsyslog/issues/4437
---
 plugins/imdiag/imdiag.c |  3 ++-
 runtime/queue.c         | 27 +++++++++++++++++++++++----
 2 files changed, 25 insertions(+), 5 deletions(-)

diff --git a/plugins/imdiag/imdiag.c b/plugins/imdiag/imdiag.c
index e1971bf..62669f6 100644
--- a/plugins/imdiag/imdiag.c
+++ b/plugins/imdiag/imdiag.c
@@ -316,6 +316,7 @@ static rsRetVal
 waitMainQEmpty(tcps_sess_t *pSess)
 {
 	int iPrint = 0;
+	int iPrintVerbosity = 500; // 500 default
 	int nempty = 0;
 	static unsigned lastOverallQueueSize = 1;
 	DEFiRet;
@@ -341,7 +342,7 @@ waitMainQEmpty(tcps_sess_t *pSess)
 		}
 		if(nempty > max_empty_checks)
 			break;
-		if(iPrint++ % 500 == 0)
+		if(iPrint++ % iPrintVerbosity == 0)
 			DBGPRINTF("imdiag sleeping, wait queues drain, "
 				"curr size %d, nempty %d\n",
 				OverallQueueSize, nempty);
diff --git a/runtime/queue.c b/runtime/queue.c
index a6c9776..5339370 100644
--- a/runtime/queue.c
+++ b/runtime/queue.c
@@ -741,8 +741,15 @@ static rsRetVal qDeqLinkedList(qqueue_t *pThis, smsg_t **ppMsg)
 	DEFiRet;
 
 	pEntry = pThis->tVars.linklist.pDeqRoot;
-	*ppMsg = pEntry->pMsg;
-	pThis->tVars.linklist.pDeqRoot = pEntry->pNext;
+	if (pEntry != NULL) {
+		*ppMsg = pEntry->pMsg;
+		pThis->tVars.linklist.pDeqRoot = pEntry->pNext;
+	} else {
+		/* Check and return NULL for linklist.pDeqRoot */
+		dbgprintf("qDeqLinkedList: pDeqRoot is NULL!\n");
+		*ppMsg = NULL;
+		pThis->tVars.linklist.pDeqRoot = NULL;
+	}
 
 	RETiRet;
 }
@@ -1885,8 +1892,20 @@ DequeueConsumableElements(qqueue_t *const pThis, wti_t *const pWti,
 	/* it is sufficient to persist only when the bulk of work is done */
 	qqueueChkPersist(pThis, nDequeued+nDiscarded+nDeleted);
 
-	DBGOPRINT((obj_t*) pThis, "dequeued %d consumable elements, szlog %d sz phys %d\n",
-		nDequeued, getLogicalQueueSize(pThis), getPhysicalQueueSize(pThis));
+	/* If messages where DISCARDED, we need to substract them from the OverallQueueSize */
+#	ifdef ENABLE_IMDIAG
+#		ifdef HAVE_ATOMIC_BUILTINS
+			ATOMIC_SUB(&iOverallQueueSize, nDiscarded, &NULL);
+#		else
+			iOverallQueueSize -= nDiscarded; /* racy, but we can't wait for a mutex! */
+#		endif
+	DBGOPRINT((obj_t*) pThis, "dequeued %d discarded %d QueueSize %d consumable elements, szlog %d sz phys %d\n",
+		nDequeued, nDiscarded, iOverallQueueSize, getLogicalQueueSize(pThis), getPhysicalQueueSize(pThis));
+#	else
+	DBGOPRINT((obj_t*) pThis, "dequeued %d discarded %d consumable elements, szlog %d sz phys %d\n",
+		nDequeued, nDiscarded, getLogicalQueueSize(pThis), getPhysicalQueueSize(pThis));
+#	endif
+
 	pWti->batch.nElem = nDequeued;
 	pWti->batch.nElemDeq = nDequeued + nDiscarded;
 	pWti->batch.deqID = getNextDeqID(pThis);
-- 
2.7.4

