From 65c2d6afd67a032f45f40d7e4d620f5d73e5f07d Mon Sep 17 00:00:00 2001
From: Simon Kelley <simon@thekelleys.org.uk>
Date: Wed, 22 Nov 2023 22:02:05 +0000
Subject: [PATCH] Fix standalone SHA256 implementation.

Bug report here:
https://lists.thekelleys.org.uk/pipermail/dnsmasq-discuss/2023q4/017332.html

This error probably has no practical effect since even if the hash
is wrong, it's only compared internally to other hashes computed using
the same code.

Understanding the error:

hash-questions.c:168:21: runtime error: left shift of 128 by 24 places
cannot be represented in type 'int'

requires a certain amount of c-lawyerliness. I think the problem is that

m[i] = data[j] << 24

promotes the unsigned char data array value to int before doing the shift and
then promotes the result to unsigned char to match the type of m[i].
What needs to happen is to cast the unsigned char to unsigned int
BEFORE the shift.

This patch does that with explicit casts.

Upstream-Status: Backport [https://thekelleys.org.uk/gitweb/?p=dnsmasq.git;a=commit;h=65c2d6afd67a032f45f40d7e4d620f5d73e5f07d]
CVE: CVE-2023-49441
Signed-off-by: Vijay Anusuri <vanusuri@mvista.com>
---
 src/hash_questions.c | 2 +-
 1 file changed, 1 insertion(+), 1 deletion(-)

diff --git a/src/hash_questions.c b/src/hash_questions.c
index c65e2a7..5e96603 100644
--- a/src/hash_questions.c
+++ b/src/hash_questions.c
@@ -162,7 +162,7 @@ static void sha256_transform(SHA256_CTX *ctx, const BYTE data[])
   WORD a, b, c, d, e, f, g, h, i, j, t1, t2, m[64];
   
   for (i = 0, j = 0; i < 16; ++i, j += 4)
-    m[i] = (data[j] << 24) | (data[j + 1] << 16) | (data[j + 2] << 8) | (data[j + 3]);
+    m[i] = (((WORD)data[j]) << 24) | (((WORD)data[j + 1]) << 16) | (((WORD)data[j + 2]) << 8) | (((WORD)data[j + 3]));
   for ( ; i < 64; ++i)
     m[i] = SIG1(m[i - 2]) + m[i - 7] + SIG0(m[i - 15]) + m[i - 16];
 
-- 
2.24.4

