From 1ad11c391ea50978e35163790bc9b687e671e346 Mon Sep 17 00:00:00 2001
From: Vivek Kumbhar <vkumbhar@mvista.com>
Date: Tue, 26 Nov 2024 14:03:13 +0000
Subject: [PATCH] CVE-2019-20892

---
 include/net-snmp/library/snmpusm.h |  5 ++-
 snmplib/snmp_client.c              | 23 +++-------
 snmplib/snmpusm.c                  | 68 ++++++++++++++++++++----------
 3 files changed, 55 insertions(+), 41 deletions(-)

diff --git a/include/net-snmp/library/snmpusm.h b/include/net-snmp/library/snmpusm.h
index 9d673cc..e437d67 100644
--- a/include/net-snmp/library/snmpusm.h
+++ b/include/net-snmp/library/snmpusm.h
@@ -34,6 +34,7 @@ extern          "C" {
      * Structures.
      */
     struct usmStateReference {
+        int             refcnt;
         char           *usr_name;
         size_t          usr_name_length;
         u_char         *usr_engine_id;
@@ -92,8 +93,10 @@ extern          "C" {
      */
     struct usmStateReference *usm_malloc_usmStateReference(void);
 
-    void            usm_free_usmStateReference(void *old);
+    static int      usm_clone(netsnmp_pdu *pdu, netsnmp_pdu *new_pdu);
 
+    static void     usm_free_usmStateReference(void *old);
+ 
     int             usm_set_usmStateReference_name(struct usmStateReference
                                                    *ref, char *name,
                                                    size_t name_len);
diff --git a/snmplib/snmp_client.c b/snmplib/snmp_client.c
index ab7a58c..7851634 100644
--- a/snmplib/snmp_client.c
+++ b/snmplib/snmp_client.c
@@ -391,27 +391,16 @@ _clone_pdu_header(netsnmp_pdu *pdu)
         return NULL;
     }
 
-    if (pdu != NULL && pdu->securityStateRef &&
-        pdu->command == SNMP_MSG_TRAP2) {
-
-        ret = usm_clone_usmStateReference((struct usmStateReference *) pdu->securityStateRef,
-                (struct usmStateReference **) &newpdu->securityStateRef );
-
-        if (ret)
-        {
+    sptr = find_sec_mod(newpdu->securityModel);
+    if (sptr && sptr->pdu_clone) {
+        /* call security model if it needs to know about this */
+        ret = sptr->pdu_clone(pdu, newpdu);
+        if (ret) {
             snmp_free_pdu(newpdu);
-            return 0;
+            return NULL;
         }
     }
 
-    if ((sptr = find_sec_mod(newpdu->securityModel)) != NULL &&
-        sptr->pdu_clone != NULL) {
-        /*
-         * call security model if it needs to know about this 
-         */
-        (*sptr->pdu_clone) (pdu, newpdu);
-    }
-
     return newpdu;
 }
 
diff --git a/snmplib/snmpusm.c b/snmplib/snmpusm.c
index 6a9cec3..6440070 100644
--- a/snmplib/snmpusm.c
+++ b/snmplib/snmpusm.c
@@ -192,41 +192,62 @@ free_enginetime_on_shutdown(int majorid, int minorid, void *serverarg,
 struct usmStateReference *
 usm_malloc_usmStateReference(void)
 {
-    struct usmStateReference *retval = (struct usmStateReference *)
-        calloc(1, sizeof(struct usmStateReference));
+    struct usmStateReference *retval;
 
+    retval = calloc(1, sizeof(struct usmStateReference));
+    if (retval)
+        retval->refcnt = 1;
+        
     return retval;
 }                               /* end usm_malloc_usmStateReference() */
 
+static int
+usm_clone(netsnmp_pdu *pdu, netsnmp_pdu *new_pdu)
+{
+    struct usmStateReference *ref = pdu->securityStateRef;
+    struct usmStateReference **new_ref =
+        (struct usmStateReference **)&new_pdu->securityStateRef;
+    int ret = 0;
+ 
+    if (!ref)
+        return ret;
+        
+    if (pdu->command == SNMP_MSG_TRAP2) {
+        netsnmp_assert(pdu->securityModel == SNMP_DEFAULT_SECMODEL);
+        ret = usm_clone_usmStateReference(ref, new_ref);
+    } else {
+        netsnmp_assert(ref == *new_ref);
+        ref->refcnt++;
+    }
+    return ret;
+}                               
 
-void
+static void
 usm_free_usmStateReference(void *old)
 {
-    struct usmStateReference *old_ref = (struct usmStateReference *) old;
-
-    if (old_ref) {
+    struct usmStateReference *ref = old;
 
-        SNMP_FREE(old_ref->usr_name);
-        SNMP_FREE(old_ref->usr_engine_id);
-        SNMP_FREE(old_ref->usr_auth_protocol);
-        SNMP_FREE(old_ref->usr_priv_protocol);
-
-        if (old_ref->usr_auth_key) {
-            SNMP_ZERO(old_ref->usr_auth_key, old_ref->usr_auth_key_length);
-            SNMP_FREE(old_ref->usr_auth_key);
-        }
-        if (old_ref->usr_priv_key) {
-            SNMP_ZERO(old_ref->usr_priv_key, old_ref->usr_priv_key_length);
-            SNMP_FREE(old_ref->usr_priv_key);
-        }
+    if (!ref)
+        return;
 
-        SNMP_ZERO(old_ref, sizeof(*old_ref));
-        SNMP_FREE(old_ref);
+    if (--ref->refcnt > 0)
+        return;
+    SNMP_FREE(ref->usr_name);
+    SNMP_FREE(ref->usr_engine_id);
+    SNMP_FREE(ref->usr_auth_protocol);
+    SNMP_FREE(ref->usr_priv_protocol);
 
+    if (ref->usr_auth_key_length && ref->usr_auth_key) {
+        SNMP_ZERO(ref->usr_auth_key, ref->usr_auth_key_length);
+        SNMP_FREE(ref->usr_auth_key);
     }
-
+    if (ref->usr_priv_key_length && ref->usr_priv_key) {
+        SNMP_ZERO(ref->usr_priv_key, ref->usr_priv_key_length);
+        SNMP_FREE(ref->usr_priv_key);
+    }
+    SNMP_FREE(ref);
 }                               /* end usm_free_usmStateReference() */
-
+ 
 struct usmUser *
 usm_get_userList(void)
 {
@@ -3216,6 +3237,7 @@ init_usm(void)
     def->encode_reverse = usm_secmod_rgenerate_out_msg;
     def->encode_forward = usm_secmod_generate_out_msg;
     def->decode = usm_secmod_process_in_msg;
+    def->pdu_clone = usm_clone;
     def->pdu_free_state_ref = usm_free_usmStateReference;
     def->session_setup = usm_session_init;
     def->handle_report = usm_handle_report;
-- 
2.18.2

